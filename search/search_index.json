{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"otcyto","text":"<p>A Python package for optimal transport\u2013based normalization and comparison of flow cytometry data.</p> <ul> <li>Install: <code>uv add otcyto</code> (or from source)</li> <li>MWE: see Getting started</li> <li>OTDpairwise documentation: OTDPairwise</li> </ul> <p>Please see the Contributing guide for more information on how to contribute to this project.</p> <ul> <li>Quick contribution guide: QuickContribute</li> <li>Initial package setup is documented in PackageSetupOverview.</li> </ul>"},{"location":"PackageSetupOverview/","title":"Development Package setup","text":"<pre><code>    pip install --upgrade pyscaffold\n    putup otcyto\n    cd otcyto\n    # Create otcyto within gitlab, without README\n    git branch -m master main\n    git remote add origin git@github.com:ggrlab/otycyto\n    git push -u origin --all\n\n    # add-apt-repository ppa:deadsnakes/ppa\n    # apt install python3.11\n\n    #  Use uv-managed virtualenv\n    # uv sync  --python /bin/python3.11\n\n    # (Optional) Add deps with uv (writes to pyproject.toml) to testing:\n    uv add --dev pytest ruff pytest-cov pre-commit\n    # Use pre-commit:\n    # https://docs.astral.sh/uv/guides/integration/pre-commit/\n\n    uv sync  --python /bin/python3.11  # or whatever python you want to use.\n    # Using your default python:\n    # uv sync\n\n    # Run common tasks via uv\n    uv run pytest                # tests\n    uv build                     # build sdist/wheel when ready to publish\n    # uv publish  # to publish on pypi\n\n    # Pre-commit with Ruff via PyScaffold extension\n    # If you haven\u2019t used the extension on creation:\n    pipx run pyscaffold putup --update . --pre-commit-ruff\n    pre-commit install\n    pre-commit autoupdate\n\n    # Documentation\n    uv add --dev mkdocs mkdocs-material mkdocstrings[python] mkdocs-section-index mkdocs-literate-nav mkdocs-gen-files\n    uv run mkdocs new .\n\n\n    # I did not get act to run properly (2025-08-13)\n    # Run the CI locally with act. (pure development)\n    wget https://github.com/nektos/act/releases/download/v0.2.80/act_Linux_x86_64.tar.gz\n    tar -xzf act_Linux_x86_64.tar.gz\n    sudo mv act /usr/local/bin/\n    rm act_Linux_x86_64.tar.gz\n\n    # From https://github.com/nektos/act/blob/a78b3f305a43a143283fb7d02f3b24df1577ce3e/cmd/root.go#L719\n    #   switch answer {\n    #   case \"Large\":\n    #       option = \"-P ubuntu-latest=catthehacker/ubuntu:full-latest\\n-P ubuntu-22.04=catthehacker/ubuntu:full-22.04\\n-P ubuntu-20.04=catthehacker/ubuntu:full-20.04\\n-P ubuntu-18.04=catthehacker/ubuntu:full-18.04\\n\"\n    #   case \"Medium\":\n    #       option = \"-P ubuntu-latest=catthehacker/ubuntu:act-latest\\n-P ubuntu-22.04=catthehacker/ubuntu:act-22.04\\n-P ubuntu-20.04=catthehacker/ubuntu:act-20.04\\n-P ubuntu-18.04=catthehacker/ubuntu:act-18.04\\n\"\n    #   case \"Micro\":\n    #       option = \"-P ubuntu-latest=node:16-buster-slim\\n-P ubuntu-22.04=node:16-bullseye-slim\\n-P ubuntu-20.04=node:16-buster-slim\\n-P ubuntu-18.04=node:16-buster-slim\\n\"\n    #   }\n    # Use the medium image for act:\n    echo \"-P ubuntu-latest=catthehacker/ubuntu:act-latest\\n-P ubuntu-22.04=catthehacker/ubuntu:act-22.04\\n-P ubuntu-20.04=catthehacker/ubuntu:act-20.04\\n-P ubuntu-18.04=catthehacker/ubuntu:act-18.04\\n\" &gt; .actrc\n</code></pre>"},{"location":"QuickContribute/","title":"Quick contribution guide","text":"<pre><code>    git clone git@github.com:ggrlab/otycyto\n\n    #  Use uv-managed virtualenv\n    uv sync  --python /bin/python3.11\n\n    # Using your default python:\n    # uv sync\n    uv run pre-commit run --all-files\n    uv run pre-commit autoupdate\n\n    # Run common tasks via uv\n    uv run pytest                # tests\n    uv build                     # build sdist/wheel when ready to publish\n\n    # Documentation\n    uv run mkdocs build\n    uv run mkdocs serve\n\n\n    # Push to run the CI\n    git push\n\n    # To create a release,\n    # 1. Create a tag\n    git tag -a v0.0.4 -m \"Release v0.0.4\"\n    # 2. Then push\n    git push\n    # Then open Releases -&gt; \"Draft a new release\" -&gt; \"Choose a tag\" -&gt; pick v0.0.3 -&gt; Publish.\n    # https://github.com/ggrlab/otycyto/releases/new\n</code></pre>"},{"location":"getting-started/","title":"MWE for <code>otcyto</code>","text":"<p>The following code snippet provides a minimal working example (MWE) for using the <code>otcyto</code> package to compute optimal transport distances between synthetic point clouds, plot the results, and visualize the Brenier map. <pre><code>    from otcyto.geomloss.create_sphere import create_sphere\n    from otcyto.otd_pairwise import OTDPairwise\n    from otcyto.plot.figure_clouds import figure_clouds\n\n    # Create synthetic point clouds\n    n = 1_000\n    source = create_sphere(n)[0]\n    target_1 = create_sphere(n)[0] + 1\n    target_2 = create_sphere(n)[0] + 2\n\n    # Compute pairwise OTD\n    otd = OTDPairwise([source], [target_1, target_2])\n    otd.compute()\n\n    # Inspect results\n    print(otd.otd_df)\n\n    # Plot and save OTD matrix\n    otd.plot().savefig(\"otd_matrix.png\")\n\n    # Optional: plot Brenier map for first target\n    otd.plot_brenier(0, 0).savefig(\"brenier_map.png\")\n\n    # Overlay point clouds\n    figure_clouds(source, target_1).savefig(\"clouds.png\")\n</code></pre></p>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>otcyto<ul> <li>check_pykeops</li> <li>geomloss<ul> <li>create_sphere</li> </ul> </li> <li>io<ul> <li>load_files_recursive</li> </ul> </li> <li>otd_pairwise</li> <li>plot<ul> <li>display_cloud</li> <li>display_cloud_mapping</li> <li>figure_clouds</li> <li>figure_umap</li> </ul> </li> </ul> </li> </ul>"},{"location":"reference/otcyto/","title":"otcyto","text":""},{"location":"reference/otcyto/#otcyto","title":"otcyto","text":""},{"location":"reference/otcyto/check_pykeops/","title":"check_pykeops","text":""},{"location":"reference/otcyto/check_pykeops/#otcyto.check_pykeops","title":"otcyto.check_pykeops","text":""},{"location":"reference/otcyto/otd_pairwise/","title":"otd_pairwise","text":""},{"location":"reference/otcyto/otd_pairwise/#otcyto.otd_pairwise","title":"otcyto.otd_pairwise","text":""},{"location":"reference/otcyto/otd_pairwise/#otcyto.otd_pairwise.OTDPairwise","title":"OTDPairwise","text":"<p>Compute pairwise Optimal Transport Distances (OTD) between sources and targets.</p> <p>Parameters:</p> Name Type Description Default <code>sources</code> <code>Sequence[TensorLike]</code> <p>list of data elements which should be \"transported\" to the targets</p> required <code>targets</code> <code>Sequence[TensorLike]</code> <p>list of data elements which the sources should be \"transported\" to</p> required <code>sources_names</code> <code>list[str] | None</code> <p>Optional names for sources. Defaults to [\"sample_0\", ...].</p> <code>None</code> <code>targets_names</code> <code>list[str] | None</code> <p>Optional names for targets. Defaults to [\"sample_0\", ...].</p> <code>None</code> <code>loss</code> <code>SamplesLoss</code> <p>GeomLoss objective to compute OTD. Defaults to <code>SamplesLoss(loss=\"sinkhorn\", p=2, blur=0.05, scaling=0.8)</code>.</p> <code>default_loss</code> <code>verbose</code> <code>bool</code> <p>If True, prints brief progress information.. Defaults to False.</p> <code>False</code> <code>intermediate_file</code> <code>PathLike | None</code> <p>If set, writes a CSV of pairwise OTDs after each update.</p> <code>None</code> <code>skipping_fun</code> <code>Callable[[int, int], bool]</code> <p>Callback returning True to skip computing (i, j).</p> <code>lambda i, j: False</code> Source code in <code>src/otcyto/otd_pairwise.py</code> <pre><code>class OTDPairwise:\n    \"\"\"\n    Compute pairwise Optimal Transport Distances (OTD) between sources and targets.\n\n    Args:\n        sources (Sequence[TensorLike]):\n            list of data elements which should be \"transported\" to the targets\n        targets (Sequence[TensorLike]):\n            list of data elements which the sources should be \"transported\" to\n        sources_names (list[str] | None, optional):\n            Optional names for sources. Defaults to [\"sample_0\", ...].\n        targets_names (list[str] | None, optional):\n            Optional names for targets. Defaults to [\"sample_0\", ...].\n        loss (SamplesLoss, optional):\n            GeomLoss objective to compute OTD. Defaults to\n            `SamplesLoss(loss=\"sinkhorn\", p=2, blur=0.05, scaling=0.8)`.\n        verbose (bool, optional):\n            If True, prints brief progress information.. Defaults to False.\n        intermediate_file (PathLike | None, optional):\n            If set, writes a CSV of pairwise OTDs after each update.\n        skipping_fun (Callable[[int, int], bool], optional):\n            Callback returning True to skip computing (i, j).\n    \"\"\"\n\n    def __init__(\n        self,\n        sources: list[TensorLike],\n        targets: list[TensorLike],\n        sources_names: list[str] | None = None,\n        targets_names: list[str] | None = None,\n        loss: SamplesLoss = default_loss,\n        verbose: bool = False,\n        intermediate_file: PathLike | None = None,\n        calculate_brenier: bool = False,\n        skipping_fun: Callable[[int, int], bool] = lambda i, j: False,\n    ) -&gt; None:\n        self.sources = sources\n        self.targets = targets\n        self.sources_names: list[str] = (\n            sources_names if sources_names is not None else [f\"sample_{i}\" for i in range(len(self.sources))]\n        )\n        self.targets_names: list[str] = (\n            targets_names if targets_names is not None else [f\"sample_{i}\" for i in range(len(self.targets))]\n        )\n\n        if len(self.sources) != len(self.sources_names):\n            raise ValueError(\"len(sources) must equal len(sources_names).\")\n        if len(self.targets) != len(self.targets_names):\n            raise ValueError(\"len(targets) must equal len(targets_names).\")\n\n        self.calculate_brenier: bool = calculate_brenier\n        self.loss: SamplesLoss = loss\n        self.verbose: bool = verbose\n        self._intermediate_file: PathLike | None = intermediate_file\n        self._skipping_fun: Callable[[int, int], bool] = skipping_fun\n\n        # Matrices to store timings (seconds) and distances.\n        ns, nt = len(self.sources), len(self.targets)\n        self._time_sec = torch.zeros((ns, nt), dtype=torch.float32)\n        self._otd_vals = torch.zeros((ns, nt), dtype=torch.float32)\n\n        # Brenier map cache; a list-of-lists holding torch.Tensors or None.\n        self._brenier_maps: list[list[TensorLike | None]] = [[None for _ in range(nt)] for _ in range(ns)]\n        self._otd_calculated: bool = False\n\n        # Validate tensor shapes/dtypes/devices early to avoid cryptic errors later.\n        self._validate_inputs()\n\n    # ----------------------------- Internal utilities -----------------------------\n\n    def _validate_inputs(self) -&gt; None:\n        \"\"\"Validate shapes, dtypes, and device compatibility for all tensors.\"\"\"\n        if len(self.sources) == 0 or len(self.targets) == 0:\n            raise ValueError(\"sources and targets must be non-empty.\")\n\n    # ----------------------------- Public properties ------------------------------\n\n    @property\n    def time_calculation(self) -&gt; pd.DataFrame:\n        \"\"\"Return a (sources x targets) DataFrame of compute times in seconds.\"\"\"\n        return pd.DataFrame(\n            self._time_sec.detach().cpu().numpy(),\n            index=self.sources_names,\n            columns=self.targets_names,\n        )\n\n    @property\n    def otd_torch(self) -&gt; torch.Tensor:\n        \"\"\"Return a CPU tensor of pairwise OTD values.\"\"\"\n        return self._otd_vals.detach().cpu()\n\n    @property\n    def otd_numpy(self) -&gt; np.ndarray:\n        \"\"\"Return a NumPy array of pairwise OTD values.\"\"\"\n        return self.otd_torch.numpy()\n\n    @property\n    def otd_df(self) -&gt; pd.DataFrame:\n        \"\"\"Return a (sources x targets) DataFrame of pairwise OTD values.\"\"\"\n        return pd.DataFrame(self.otd_numpy, index=self.sources_names, columns=self.targets_names)\n\n    @property\n    def brenier_maps(self) -&gt; list[list[TensorLike | None]]:\n        \"\"\"Access the cached Brenier maps; may be None if not computed.\"\"\"\n        return self._brenier_maps\n\n    # ----------------------------- Persistence -----------------------------------\n\n    def save_intermediate(self, filename: PathLike) -&gt; None:\n        \"\"\"Save the current OTD matrix to CSV.\"\"\"\n        self.otd_df.to_csv(Path(filename))\n        if self.verbose:\n            print(f\"    Wrote {filename}\")\n\n    # ----------------------------- Core computation ------------------------------\n\n    def compute(self) -&gt; None:\n        \"\"\"Compute pairwise OTD between every source and target without gradients.\n\n        Notes\n        -----\n        - This method per default avoids building autograd graphs to stay light.\n        - If `self.calculate_brenier` is True, gradients are built only long enough\n            to obtain the Brenier map for each computed pair, then discarded.\n        - If False, this avoids building autograd graphs; maps can be obtained later\n            via `get_brenier_map(i, j)` (which recomputes that pair once).\n\n        \"\"\"\n        ns, nt = len(self.sources), len(self.targets)\n        for source_i in range(ns):\n            for target_j in range(nt):\n                # Skip the pair if skipping_fun returns True\n                if self._skipping_fun(source_i, target_j):\n                    if self.verbose:\n                        print(f\"Skipping {self.sources_names[source_i]}\" + \" -&gt; \" + f\"{self.targets_names[target_j]}\")\n                    continue\n                if self.verbose:\n                    print(\n                        \"Compute OTD from\",\n                        self.sources_names[source_i],\n                        \"to\",\n                        self.targets_names[target_j],\n                        end=\" \",\n                        flush=True,\n                    )\n                # Get the source and target samples\n                x_i = self.sources[source_i]\n                y_j = self.targets[target_j]\n                # Time using a monotonic high-resolution timer.\n                t0 = time.perf_counter()\n                if self.calculate_brenier:\n                    loss_val, br_map = self.single_brenier(source=x_i, target=y_j)\n                    self._brenier_maps[source_i][target_j] = br_map.detach().cpu()\n                    dist_ij = loss_val.detach()\n                else:\n                    with torch.no_grad():\n                        # Compute the optimal transport distance (OTD) using the provided\n                        # loss function\n                        dist_ij = self.loss(x_i, y_j)\n                t1 = time.perf_counter()\n\n                # Store values (detach to be explicit; dist_ij has no grad anyway).\n                self._otd_vals[source_i, target_j] = float(dist_ij)\n                self._time_sec[source_i, target_j] = float(t1 - t0)\n\n                if self.verbose:\n                    print(\n                        f\"Computed OTD {self.sources_names[source_i]}\"\n                        + \" -&gt; \"\n                        + \"{self.targets_names[target_j]} \"\n                        + f\"= {float(dist_ij):.6g}  (t={t1 - t0:.3f}s)\"\n                    )\n\n                if self._intermediate_file is not None:\n                    # Save the intermediate results to a file if an intermediate\n                    #  file path is provided\n                    self.save_intermediate(self._intermediate_file)\n\n        self._otd_calculated = True\n\n    def single_brenier(self, source: torch.Tensor, target: torch.Tensor) -&gt; tuple[Any, torch.Tensor]:\n        \"\"\"Calculate the Brenier map for a given source and target.\n\n        Args:\n            source (torch.Tensor): The source point cloud.\n            target (torch.Tensor): The target point cloud.\n\n        Returns:\n            torch.Tensor: The Brenier map as a tensor.\n        \"\"\"\n\n        # https://www.kernel-operations.io/geomloss/_auto_examples/sinkhorn_multiscale/plot_kernel_truncation.html#sphx-glr-auto-examples-sinkhorn-multiscale-plot-kernel-truncation-py\n        #  The generalized \"Brenier map\" is (minus) the gradient of the Sinkhorn loss\n        # with respect to the Wasserstein metric:\n        self._brenier_maps: list[list[TensorLike | None]]\n        # Clone to ensure a leaf tensor with gradients enabled.\n        x_leaf = source.detach().clone().requires_grad_(True)\n        #  no grad needed for y\n        # Compute loss with a live graph.\n        loss_val = self.loss(x_leaf, target)\n        # Gradient of scalar loss w.r.t. x; retain_graph not needed since we discard it.\n        (dx,) = grad(loss_val, (x_leaf,), create_graph=False, retain_graph=False)\n        # Map is minus the gradient; scale if needed depending on your convention.\n        # Given each point has the same weight, we need to multiply the\n        # Brenier map by the number of points in the source\n        br_map = (-dx) * x_leaf.shape[0]\n        return loss_val, br_map\n\n    def get_brenier_map(self, source_i: int, target_j: int) -&gt; TensorLike:\n        \"\"\"Get the Brenier map for a specific source and target.\n\n        Args:\n            source_i (int): Index of the source sample.\n            target_j (int): Index of the target sample.\n\n        Returns:\n            TensorLike: The Brenier map tensor for the specified pair.\n        \"\"\"\n        if not self._otd_calculated:\n            raise RuntimeError(\"OTD must be computed before accessing Brenier maps. Call `.compute()` first.\")\n\n        br_map = self._brenier_maps[source_i][target_j]\n        if br_map is None:\n            # Recompute if not cached\n            _, br_map = self.single_brenier(source=self.sources[source_i], target=self.targets[target_j])\n        return br_map\n\n    # ----------------------------- Plotting --------------------------------------\n\n    def plot(self, source_i: int = 0, target_j: int = 0, npoints: int = 10_000):\n        \"\"\"Scatter plot of a given source and target sample.\"\"\"\n        fig = figure_clouds(\n            self.sources[source_i].detach().cpu(),\n            self.targets[target_j].detach().cpu(),\n            npoints=npoints,\n        )\n        return fig\n\n    def plot_brenier(\n        self,\n        source_i: int = 0,\n        target_j: int = 0,\n        x_i: int = 0,\n        y_i: int = 1,\n        color_mapping: str = \"#5BBF3AAA\",\n        npoints: int = 10_000,\n    ):\n        \"\"\"Plot source/target clouds and visualize the Brenier map arrows.\"\"\"\n        # Ensure map is computed.\n        br_map = self.get_brenier_map(source_i, target_j)\n\n        fig = figure_clouds(\n            self.sources[source_i].detach().cpu(),\n            self.targets[target_j].detach().cpu(),\n            x_i=x_i,\n            y_i=y_i,\n            map_source_to_target=br_map,\n            color_mapping=color_mapping,\n            npoints=npoints,\n        )\n        return fig\n\n    def plot_umap(self, source_i: int = 0, target_j: int = 0):\n        raise NotImplementedError(\"UMAP plotting is not implemented.\")\n</code></pre>"},{"location":"reference/otcyto/otd_pairwise/#otcyto.otd_pairwise.OTDPairwise.brenier_maps","title":"brenier_maps  <code>property</code>","text":"<pre><code>brenier_maps\n</code></pre> <p>Access the cached Brenier maps; may be None if not computed.</p>"},{"location":"reference/otcyto/otd_pairwise/#otcyto.otd_pairwise.OTDPairwise.otd_df","title":"otd_df  <code>property</code>","text":"<pre><code>otd_df\n</code></pre> <p>Return a (sources x targets) DataFrame of pairwise OTD values.</p>"},{"location":"reference/otcyto/otd_pairwise/#otcyto.otd_pairwise.OTDPairwise.otd_numpy","title":"otd_numpy  <code>property</code>","text":"<pre><code>otd_numpy\n</code></pre> <p>Return a NumPy array of pairwise OTD values.</p>"},{"location":"reference/otcyto/otd_pairwise/#otcyto.otd_pairwise.OTDPairwise.otd_torch","title":"otd_torch  <code>property</code>","text":"<pre><code>otd_torch\n</code></pre> <p>Return a CPU tensor of pairwise OTD values.</p>"},{"location":"reference/otcyto/otd_pairwise/#otcyto.otd_pairwise.OTDPairwise.time_calculation","title":"time_calculation  <code>property</code>","text":"<pre><code>time_calculation\n</code></pre> <p>Return a (sources x targets) DataFrame of compute times in seconds.</p>"},{"location":"reference/otcyto/otd_pairwise/#otcyto.otd_pairwise.OTDPairwise.compute","title":"compute","text":"<pre><code>compute()\n</code></pre> <p>Compute pairwise OTD between every source and target without gradients.</p>"},{"location":"reference/otcyto/otd_pairwise/#otcyto.otd_pairwise.OTDPairwise.compute--notes","title":"Notes","text":"<ul> <li>This method per default avoids building autograd graphs to stay light.</li> <li>If <code>self.calculate_brenier</code> is True, gradients are built only long enough     to obtain the Brenier map for each computed pair, then discarded.</li> <li>If False, this avoids building autograd graphs; maps can be obtained later     via <code>get_brenier_map(i, j)</code> (which recomputes that pair once).</li> </ul> Source code in <code>src/otcyto/otd_pairwise.py</code> <pre><code>def compute(self) -&gt; None:\n    \"\"\"Compute pairwise OTD between every source and target without gradients.\n\n    Notes\n    -----\n    - This method per default avoids building autograd graphs to stay light.\n    - If `self.calculate_brenier` is True, gradients are built only long enough\n        to obtain the Brenier map for each computed pair, then discarded.\n    - If False, this avoids building autograd graphs; maps can be obtained later\n        via `get_brenier_map(i, j)` (which recomputes that pair once).\n\n    \"\"\"\n    ns, nt = len(self.sources), len(self.targets)\n    for source_i in range(ns):\n        for target_j in range(nt):\n            # Skip the pair if skipping_fun returns True\n            if self._skipping_fun(source_i, target_j):\n                if self.verbose:\n                    print(f\"Skipping {self.sources_names[source_i]}\" + \" -&gt; \" + f\"{self.targets_names[target_j]}\")\n                continue\n            if self.verbose:\n                print(\n                    \"Compute OTD from\",\n                    self.sources_names[source_i],\n                    \"to\",\n                    self.targets_names[target_j],\n                    end=\" \",\n                    flush=True,\n                )\n            # Get the source and target samples\n            x_i = self.sources[source_i]\n            y_j = self.targets[target_j]\n            # Time using a monotonic high-resolution timer.\n            t0 = time.perf_counter()\n            if self.calculate_brenier:\n                loss_val, br_map = self.single_brenier(source=x_i, target=y_j)\n                self._brenier_maps[source_i][target_j] = br_map.detach().cpu()\n                dist_ij = loss_val.detach()\n            else:\n                with torch.no_grad():\n                    # Compute the optimal transport distance (OTD) using the provided\n                    # loss function\n                    dist_ij = self.loss(x_i, y_j)\n            t1 = time.perf_counter()\n\n            # Store values (detach to be explicit; dist_ij has no grad anyway).\n            self._otd_vals[source_i, target_j] = float(dist_ij)\n            self._time_sec[source_i, target_j] = float(t1 - t0)\n\n            if self.verbose:\n                print(\n                    f\"Computed OTD {self.sources_names[source_i]}\"\n                    + \" -&gt; \"\n                    + \"{self.targets_names[target_j]} \"\n                    + f\"= {float(dist_ij):.6g}  (t={t1 - t0:.3f}s)\"\n                )\n\n            if self._intermediate_file is not None:\n                # Save the intermediate results to a file if an intermediate\n                #  file path is provided\n                self.save_intermediate(self._intermediate_file)\n\n    self._otd_calculated = True\n</code></pre>"},{"location":"reference/otcyto/otd_pairwise/#otcyto.otd_pairwise.OTDPairwise.get_brenier_map","title":"get_brenier_map","text":"<pre><code>get_brenier_map(source_i, target_j)\n</code></pre> <p>Get the Brenier map for a specific source and target.</p> <p>Parameters:</p> Name Type Description Default <code>source_i</code> <code>int</code> <p>Index of the source sample.</p> required <code>target_j</code> <code>int</code> <p>Index of the target sample.</p> required <p>Returns:</p> Name Type Description <code>TensorLike</code> <code>TensorLike</code> <p>The Brenier map tensor for the specified pair.</p> Source code in <code>src/otcyto/otd_pairwise.py</code> <pre><code>def get_brenier_map(self, source_i: int, target_j: int) -&gt; TensorLike:\n    \"\"\"Get the Brenier map for a specific source and target.\n\n    Args:\n        source_i (int): Index of the source sample.\n        target_j (int): Index of the target sample.\n\n    Returns:\n        TensorLike: The Brenier map tensor for the specified pair.\n    \"\"\"\n    if not self._otd_calculated:\n        raise RuntimeError(\"OTD must be computed before accessing Brenier maps. Call `.compute()` first.\")\n\n    br_map = self._brenier_maps[source_i][target_j]\n    if br_map is None:\n        # Recompute if not cached\n        _, br_map = self.single_brenier(source=self.sources[source_i], target=self.targets[target_j])\n    return br_map\n</code></pre>"},{"location":"reference/otcyto/otd_pairwise/#otcyto.otd_pairwise.OTDPairwise.plot","title":"plot","text":"<pre><code>plot(source_i=0, target_j=0, npoints=10000)\n</code></pre> <p>Scatter plot of a given source and target sample.</p> Source code in <code>src/otcyto/otd_pairwise.py</code> <pre><code>def plot(self, source_i: int = 0, target_j: int = 0, npoints: int = 10_000):\n    \"\"\"Scatter plot of a given source and target sample.\"\"\"\n    fig = figure_clouds(\n        self.sources[source_i].detach().cpu(),\n        self.targets[target_j].detach().cpu(),\n        npoints=npoints,\n    )\n    return fig\n</code></pre>"},{"location":"reference/otcyto/otd_pairwise/#otcyto.otd_pairwise.OTDPairwise.plot_brenier","title":"plot_brenier","text":"<pre><code>plot_brenier(\n    source_i=0,\n    target_j=0,\n    x_i=0,\n    y_i=1,\n    color_mapping=\"#5BBF3AAA\",\n    npoints=10000,\n)\n</code></pre> <p>Plot source/target clouds and visualize the Brenier map arrows.</p> Source code in <code>src/otcyto/otd_pairwise.py</code> <pre><code>def plot_brenier(\n    self,\n    source_i: int = 0,\n    target_j: int = 0,\n    x_i: int = 0,\n    y_i: int = 1,\n    color_mapping: str = \"#5BBF3AAA\",\n    npoints: int = 10_000,\n):\n    \"\"\"Plot source/target clouds and visualize the Brenier map arrows.\"\"\"\n    # Ensure map is computed.\n    br_map = self.get_brenier_map(source_i, target_j)\n\n    fig = figure_clouds(\n        self.sources[source_i].detach().cpu(),\n        self.targets[target_j].detach().cpu(),\n        x_i=x_i,\n        y_i=y_i,\n        map_source_to_target=br_map,\n        color_mapping=color_mapping,\n        npoints=npoints,\n    )\n    return fig\n</code></pre>"},{"location":"reference/otcyto/otd_pairwise/#otcyto.otd_pairwise.OTDPairwise.save_intermediate","title":"save_intermediate","text":"<pre><code>save_intermediate(filename)\n</code></pre> <p>Save the current OTD matrix to CSV.</p> Source code in <code>src/otcyto/otd_pairwise.py</code> <pre><code>def save_intermediate(self, filename: PathLike) -&gt; None:\n    \"\"\"Save the current OTD matrix to CSV.\"\"\"\n    self.otd_df.to_csv(Path(filename))\n    if self.verbose:\n        print(f\"    Wrote {filename}\")\n</code></pre>"},{"location":"reference/otcyto/otd_pairwise/#otcyto.otd_pairwise.OTDPairwise.single_brenier","title":"single_brenier","text":"<pre><code>single_brenier(source, target)\n</code></pre> <p>Calculate the Brenier map for a given source and target.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>Tensor</code> <p>The source point cloud.</p> required <code>target</code> <code>Tensor</code> <p>The target point cloud.</p> required <p>Returns:</p> Type Description <code>tuple[Any, Tensor]</code> <p>torch.Tensor: The Brenier map as a tensor.</p> Source code in <code>src/otcyto/otd_pairwise.py</code> <pre><code>def single_brenier(self, source: torch.Tensor, target: torch.Tensor) -&gt; tuple[Any, torch.Tensor]:\n    \"\"\"Calculate the Brenier map for a given source and target.\n\n    Args:\n        source (torch.Tensor): The source point cloud.\n        target (torch.Tensor): The target point cloud.\n\n    Returns:\n        torch.Tensor: The Brenier map as a tensor.\n    \"\"\"\n\n    # https://www.kernel-operations.io/geomloss/_auto_examples/sinkhorn_multiscale/plot_kernel_truncation.html#sphx-glr-auto-examples-sinkhorn-multiscale-plot-kernel-truncation-py\n    #  The generalized \"Brenier map\" is (minus) the gradient of the Sinkhorn loss\n    # with respect to the Wasserstein metric:\n    self._brenier_maps: list[list[TensorLike | None]]\n    # Clone to ensure a leaf tensor with gradients enabled.\n    x_leaf = source.detach().clone().requires_grad_(True)\n    #  no grad needed for y\n    # Compute loss with a live graph.\n    loss_val = self.loss(x_leaf, target)\n    # Gradient of scalar loss w.r.t. x; retain_graph not needed since we discard it.\n    (dx,) = grad(loss_val, (x_leaf,), create_graph=False, retain_graph=False)\n    # Map is minus the gradient; scale if needed depending on your convention.\n    # Given each point has the same weight, we need to multiply the\n    # Brenier map by the number of points in the source\n    br_map = (-dx) * x_leaf.shape[0]\n    return loss_val, br_map\n</code></pre>"},{"location":"reference/otcyto/geomloss/","title":"geomloss","text":""},{"location":"reference/otcyto/geomloss/#otcyto.geomloss","title":"otcyto.geomloss","text":""},{"location":"reference/otcyto/geomloss/create_sphere/","title":"create_sphere","text":""},{"location":"reference/otcyto/geomloss/create_sphere/#otcyto.geomloss.create_sphere","title":"otcyto.geomloss.create_sphere","text":""},{"location":"reference/otcyto/geomloss/create_sphere/#otcyto.geomloss.create_sphere.create_sphere","title":"create_sphere","text":"<pre><code>create_sphere(n_samples=1000, use_cuda=True)\n</code></pre> <p>Creates a uniform sample on the unit sphere.</p> <p>Parameters:</p> Name Type Description Default <code>n_samples</code> <code>int</code> <p>Number of samples to generate. Defaults to 1000.</p> <code>1000</code> <code>use_cuda</code> <code>bool</code> <p>If True, use CUDA for tensor operations. Defaults to True.</p> <code>True</code> <p>Returns:</p> Type Description <p>Tuple[torch.Tensor, torch.Tensor]: A tuple containing: - points (torch.Tensor): Tensor of shape (n_samples, 3) with the coordinates of the points on the sphere. - weights (torch.Tensor): Tensor of shape (n_samples,) with the weights of the points.</p> Source code in <code>src/otcyto/geomloss/create_sphere.py</code> <pre><code>def create_sphere(n_samples: int | float = 1000, use_cuda: bool = True):\n    \"\"\"Creates a uniform sample on the unit sphere.\n\n    Args:\n        n_samples (int, optional): Number of samples to generate. Defaults to 1000.\n        use_cuda (bool, optional): If True, use CUDA for tensor operations. Defaults to True.\n\n    Returns:\n        Tuple[torch.Tensor, torch.Tensor]: A tuple containing:\n            - points (torch.Tensor): Tensor of shape (n_samples, 3) with the coordinates of the points on the sphere.\n            - weights (torch.Tensor): Tensor of shape (n_samples,) with the weights of the points.\n    \"\"\"\n    n_samples = int(n_samples)\n\n    # Indices for generating points\n    indices = np.arange(0, n_samples, dtype=float) + 0.5\n    # Spherical coordinates\n    phi = np.arccos(1 - 2 * indices / n_samples)\n    theta = np.pi * (1 + 5**0.5) * indices\n\n    # Cartesian coordinates\n    x, y, z = np.cos(theta) * np.sin(phi), np.sin(theta) * np.sin(phi), np.cos(phi)\n    points = np.vstack((x, y, z)).T\n    # Uniform weights\n    weights = np.ones(n_samples) / n_samples\n\n    # Convert to torch tensors\n    weights = torch.tensor(weights)\n    points = torch.tensor(points)\n\n    # Move to GPU if available and requested\n    if torch.cuda.is_available() and use_cuda:\n        weights = weights.cuda()\n        points = points.cuda()\n    return points, weights\n</code></pre>"},{"location":"reference/otcyto/io/","title":"io","text":""},{"location":"reference/otcyto/io/#otcyto.io","title":"otcyto.io","text":""},{"location":"reference/otcyto/io/load_files_recursive/","title":"load_files_recursive","text":""},{"location":"reference/otcyto/io/load_files_recursive/#otcyto.io.load_files_recursive","title":"otcyto.io.load_files_recursive","text":""},{"location":"reference/otcyto/plot/","title":"plot","text":""},{"location":"reference/otcyto/plot/#otcyto.plot","title":"otcyto.plot","text":""},{"location":"reference/otcyto/plot/display_cloud/","title":"display_cloud","text":""},{"location":"reference/otcyto/plot/display_cloud/#otcyto.plot.display_cloud","title":"otcyto.plot.display_cloud","text":""},{"location":"reference/otcyto/plot/display_cloud/#otcyto.plot.display_cloud.display_cloud","title":"display_cloud","text":"<pre><code>display_cloud(\n    ax,\n    measure,\n    color=None,\n    x_i=0,\n    y_i=1,\n    npoints=None,\n    **kwargs,\n)\n</code></pre> <p>Plot a 2D point cloud on a Matplotlib axis.</p>"},{"location":"reference/otcyto/plot/display_cloud/#otcyto.plot.display_cloud.display_cloud--parameters","title":"Parameters","text":"<p>ax     Target Matplotlib axis. measure     Point data with shape (N, D). Accepts NumPy arrays, PyTorch tensors, or any     array-like convertible to a 2D NumPy array. color     Optional Matplotlib color for points. If omitted, Matplotlib defaults apply. x_i     Column index for x-coordinates (default: 0). y_i     Column index for y-coordinates (default: 1). npoints     If provided, plot at most this many points (from the start). **kwargs     Extra keyword args forwarded to <code>ax.scatter</code> (e.g., s=4, alpha=0.6).</p>"},{"location":"reference/otcyto/plot/display_cloud/#otcyto.plot.display_cloud.display_cloud--returns","title":"Returns","text":"<p>PathCollection     The scatter plot artist returned by <code>ax.scatter</code>.</p> Source code in <code>src/otcyto/plot/display_cloud.py</code> <pre><code>def display_cloud(\n    ax: Axes,\n    measure: ArrayLike | torch.Tensor,\n    color: str | None = None,\n    x_i: int = 0,\n    y_i: int = 1,\n    npoints: int | None = None,\n    **kwargs,\n):\n    \"\"\"Plot a 2D point cloud on a Matplotlib axis.\n\n    Parameters\n    ----------\n    ax\n        Target Matplotlib axis.\n    measure\n        Point data with shape (N, D). Accepts NumPy arrays, PyTorch tensors, or any\n        array-like convertible to a 2D NumPy array.\n    color\n        Optional Matplotlib color for points. If omitted, Matplotlib defaults apply.\n    x_i\n        Column index for x-coordinates (default: 0).\n    y_i\n        Column index for y-coordinates (default: 1).\n    npoints\n        If provided, plot at most this many points (from the start).\n    **kwargs\n        Extra keyword args forwarded to ``ax.scatter`` (e.g., s=4, alpha=0.6).\n\n    Returns\n    -------\n    PathCollection\n        The scatter plot artist returned by ``ax.scatter``.\n\n    \"\"\"\n    # --- Convert input to a NumPy array (copy avoided when possible).\n    if torch is not None and isinstance(measure, torch.Tensor):\n        # Move to CPU if necessary and detach from graph; convert to NumPy\n        np_measure = measure.detach().cpu().numpy()\n    else:\n        # np.asarray handles list-like inputs; dtype=None preserves numeric dtype\n        try:\n            np_measure = np.asarray(measure)\n        except Exception as exc:  # defensive: non-array-like inputs\n            raise TypeError(\"measure must be array-like or a torch.Tensor\") from exc\n\n    # --- Validate dimensionality: need a 2D array with at least 2 columns.\n    if np_measure.ndim != 2:\n        raise ValueError(f\"measure must be 2D, got shape {np_measure.shape!r}\")\n    n_rows, n_cols = np_measure.shape\n    if n_cols &lt; 2:\n        raise ValueError(f\"measure must have at least 2 columns, got {n_cols}\")\n\n    # --- Validate indices.\n    if not (0 &lt;= x_i &lt; n_cols) or not (0 &lt;= y_i &lt; n_cols):\n        raise ValueError(f\"x_i and y_i must be in [0, {n_cols - 1}]; got x_i={x_i}, y_i={y_i}\")\n    if x_i == y_i:\n        # Usually unintended for a 2D scatter; keep explicit to avoid flat lines.\n        raise ValueError(\"x_i and y_i must refer to different columns\")\n\n    # --- Optionally downsample to the first npoints rows.\n    if npoints is not None:\n        if npoints &lt;= 0:\n            raise ValueError(\"npoints must be a positive integer\")\n        npoints = min(int(npoints), n_rows)\n        np_measure = np_measure[:npoints, :]\n\n    # --- Plot with equal aspect for spatial data.\n    ax.set_aspect(\"equal\")\n\n    # Respect user-specified color precedence: explicit 'c' in kwargs wins.\n    if color is not None and \"c\" not in kwargs:\n        kwargs[\"c\"] = color\n\n    # --- Create scatter plot.\n    return ax.scatter(np_measure[:, x_i], np_measure[:, y_i], **kwargs)\n</code></pre>"},{"location":"reference/otcyto/plot/display_cloud_mapping/","title":"display_cloud_mapping","text":""},{"location":"reference/otcyto/plot/display_cloud_mapping/#otcyto.plot.display_cloud_mapping","title":"otcyto.plot.display_cloud_mapping","text":""},{"location":"reference/otcyto/plot/display_cloud_mapping/#otcyto.plot.display_cloud_mapping.display_cloud_mapping","title":"display_cloud_mapping","text":"<pre><code>display_cloud_mapping(\n    ax,\n    x,\n    color,\n    x_i=0,\n    y_i=1,\n    v=None,\n    color_mapping=\"#5BBF3AAA\",\n    npoints=None,\n    **scatter_kwargs,\n)\n</code></pre> <p>Scatter a 2D projection of a point cloud and optionally plot a vector field.</p>"},{"location":"reference/otcyto/plot/display_cloud_mapping/#otcyto.plot.display_cloud_mapping.display_cloud_mapping--parameters","title":"Parameters","text":"<p>ax : matplotlib.axes.Axes     Target axes to draw on. x : (n, d) array-like of float     Point cloud; only columns <code>x_i</code> and <code>y_i</code> are used for plotting.     Accepts NumPy arrays or torch.Tensors (auto-converted to CPU NumPy). color : str or (n,) array-like     Matplotlib-compatible color specification for the scatter points. x_i : int, default=0     Column index to use as X. y_i : int, default=1     Column index to use as Y. v : (n, d) array-like of float, optional     Vector field aligned with <code>x</code> (e.g., a Brenier map). If provided, a     quiver plot is drawn using components <code>[x_i, y_i]</code>. color_mapping : str, default=\"#5BBF3AAA\"     Color for the quiver arrows (supports RGBA hex). npoints : int, optional     If provided, only the first <code>npoints</code> rows are plotted (both <code>x</code> and <code>v</code>). scatter_args, *scatter_kwargs     Extra arguments forwarded to <code>Axes.scatter</code>.</p>"},{"location":"reference/otcyto/plot/display_cloud_mapping/#otcyto.plot.display_cloud_mapping.display_cloud_mapping--returns","title":"Returns","text":"<p>(PathCollection, Quiver | None)     The scatter artist and the quiver artist (or None if <code>v</code> is None).</p>"},{"location":"reference/otcyto/plot/display_cloud_mapping/#otcyto.plot.display_cloud_mapping.display_cloud_mapping--raises","title":"Raises","text":"<p>TypeError     If inputs are not arrays/tensors. ValueError     If shapes are invalid, indices are out of bounds, or lengths mismatch.</p>"},{"location":"reference/otcyto/plot/display_cloud_mapping/#otcyto.plot.display_cloud_mapping.display_cloud_mapping--notes","title":"Notes","text":"<ul> <li>This function does not random-subsample; it takes the first <code>npoints</code>.   For representative subsets on unordered data, consider a random or stratified   sampler upstream.</li> </ul> Source code in <code>src/otcyto/plot/display_cloud_mapping.py</code> <pre><code>def display_cloud_mapping(\n    ax: Axes,\n    x: ArrayLike,\n    color: str | np.ndarray,\n    x_i: int = 0,\n    y_i: int = 1,\n    v: ArrayLike | None = None,\n    color_mapping: str = \"#5BBF3AAA\",\n    npoints: int | None = None,\n    **scatter_kwargs: Any,\n) -&gt; tuple[PathCollection, Quiver | None]:\n    \"\"\"\n    Scatter a 2D projection of a point cloud and optionally plot a vector field.\n\n    Parameters\n    ----------\n    ax : matplotlib.axes.Axes\n        Target axes to draw on.\n    x : (n, d) array-like of float\n        Point cloud; only columns `x_i` and `y_i` are used for plotting.\n        Accepts NumPy arrays or torch.Tensors (auto-converted to CPU NumPy).\n    color : str or (n,) array-like\n        Matplotlib-compatible color specification for the scatter points.\n    x_i : int, default=0\n        Column index to use as X.\n    y_i : int, default=1\n        Column index to use as Y.\n    v : (n, d) array-like of float, optional\n        Vector field aligned with `x` (e.g., a Brenier map). If provided, a\n        quiver plot is drawn using components `[x_i, y_i]`.\n    color_mapping : str, default=\"#5BBF3AAA\"\n        Color for the quiver arrows (supports RGBA hex).\n    npoints : int, optional\n        If provided, only the first `npoints` rows are plotted (both `x` and `v`).\n    *scatter_args, **scatter_kwargs\n        Extra arguments forwarded to `Axes.scatter`.\n\n    Returns\n    -------\n    (PathCollection, Quiver | None)\n        The scatter artist and the quiver artist (or None if `v` is None).\n\n    Raises\n    ------\n    TypeError\n        If inputs are not arrays/tensors.\n    ValueError\n        If shapes are invalid, indices are out of bounds, or lengths mismatch.\n\n    Notes\n    -----\n    - This function does not random-subsample; it takes the *first* `npoints`.\n      For representative subsets on unordered data, consider a random or stratified\n      sampler upstream.\n    \"\"\"\n    # ---- Normalize &amp; validate inputs ------------------------------------------------\n    x_np = _to_numpy(x, \"x\")\n\n    if not (0 &lt;= x_i &lt; x_np.shape[1]) or not (0 &lt;= y_i &lt; x_np.shape[1]):\n        raise ValueError(f\"x_i and y_i must be within [0, {x_np.shape[1] - 1}]; got x_i={x_i}, y_i={y_i}.\")\n\n    v_np: np.ndarray | None = None\n    if v is not None:\n        v_np = _to_numpy(v, \"v\")\n        if v_np.shape != x_np.shape:\n            raise ValueError(f\"v must have the same shape as x; got x{tuple(x_np.shape)} vs v{tuple(v_np.shape)}.\")\n\n    # ---- Optional downsampling (deterministic: first n rows) -----------------------\n    if npoints is not None:\n        if npoints &lt;= 0:\n            raise ValueError(\"npoints must be a positive integer.\")\n        n = min(npoints, x_np.shape[0])\n        x_np = x_np[:n, :]\n        if v_np is not None:\n            v_np = v_np[:n, :]\n\n    # ---- Scatter plot ---------------------------------------------------------------\n    # Use edgecolors=\"none\" to avoid a slow stroke around many tiny points.\n    scatter_artist = ax.scatter(\n        x_np[:, x_i],\n        x_np[:, y_i],\n        c=color,\n        edgecolors=\"none\",\n        **scatter_kwargs,\n    )\n\n    # ---- Optional quiver for vector field ------------------------------------------\n    quiver_artist: Quiver | None = None\n    if v_np is not None:\n        quiver_artist = ax.quiver(\n            x_np[:, x_i],\n            x_np[:, y_i],\n            v_np[:, x_i],\n            v_np[:, y_i],\n            scale=1.0,  # use data units for arrow length\n            scale_units=\"xy\",\n            color=color_mapping,\n            zorder=3,\n            width=2e-3,  # thin arrows; adjust as needed for DPI/axes size\n        )\n\n    return scatter_artist, quiver_artist\n</code></pre>"},{"location":"reference/otcyto/plot/figure_clouds/","title":"figure_clouds","text":""},{"location":"reference/otcyto/plot/figure_clouds/#otcyto.plot.figure_clouds","title":"otcyto.plot.figure_clouds","text":""},{"location":"reference/otcyto/plot/figure_clouds/#otcyto.plot.figure_clouds.figure_clouds","title":"figure_clouds","text":"<pre><code>figure_clouds(\n    source_pointcloud,\n    target_pointcloud,\n    x_i=0,\n    y_i=1,\n    map_source_to_target=None,\n    color_mapping=\"#5BBF3AAA\",\n    label_source=\"Source\",\n    label_target=\"Target\",\n    color_source=\"#0000FFA0\",\n    color_target=\"#FF0000A0\",\n    npoints=1000,\n    *,\n    figsize=(12.0, 12.0),\n    legend_loc=\"upper left\",\n    tight_layout=True,\n)\n</code></pre> <p>Create a figure displaying two 2D point clouds and (optionally) their mapping.</p>"},{"location":"reference/otcyto/plot/figure_clouds/#otcyto.plot.figure_clouds.figure_clouds--parameters","title":"Parameters","text":"<p>source_pointcloud     Source points with shape (N, D). Accepts torch.Tensor or any array-like     that your plotting helpers can consume. target_pointcloud     Target points with shape (M, D). Same accepted types as <code>source_pointcloud</code>. x_i, y_i     Column indices to plot on the x and y axes. map_source_to_target     Optional mapping information passed through to <code>display_cloud_mapping</code>.     Typically a torch.Tensor describing correspondences or flow-related weights. color_mapping     Color used by the mapping overlay (RGBA hex supported). label_source, label_target     Legend labels for source and target clouds. color_source, color_target     Colors for the source and target scatter points (RGBA hex supported). npoints     If provided, plot at most this many points from each cloud (head of the array).     Use <code>None</code> to plot all points. figsize     Matplotlib figure size. legend_loc     Legend location passed to <code>plt.legend</code>. tight_layout     Whether to call <code>plt.tight_layout()</code> before returning.</p>"},{"location":"reference/otcyto/plot/figure_clouds/#otcyto.plot.figure_clouds.figure_clouds--returns","title":"Returns","text":"<p>matplotlib.figure.Figure     The created figure.</p>"},{"location":"reference/otcyto/plot/figure_clouds/#otcyto.plot.figure_clouds.figure_clouds--raises","title":"Raises","text":"<p>ValueError     If indices are invalid or <code>npoints</code> is non-positive (when provided).</p> Source code in <code>src/otcyto/plot/figure_clouds.py</code> <pre><code>def figure_clouds(\n    source_pointcloud: Any,\n    target_pointcloud: Any,\n    x_i: int = 0,\n    y_i: int = 1,\n    map_source_to_target: torch.Tensor | None = None,\n    color_mapping: str = \"#5BBF3AAA\",\n    label_source: str = \"Source\",\n    label_target: str = \"Target\",\n    color_source: str = \"#0000FFA0\",\n    color_target: str = \"#FF0000A0\",\n    npoints: int | None = 1000,\n    *,\n    figsize: tuple[float, float] = (12.0, 12.0),\n    legend_loc: str = \"upper left\",\n    tight_layout: bool = True,\n) -&gt; Figure:\n    \"\"\"Create a figure displaying two 2D point clouds and (optionally) their mapping.\n\n    Parameters\n    ----------\n    source_pointcloud\n        Source points with shape (N, D). Accepts torch.Tensor or any array-like\n        that your plotting helpers can consume.\n    target_pointcloud\n        Target points with shape (M, D). Same accepted types as ``source_pointcloud``.\n    x_i, y_i\n        Column indices to plot on the x and y axes.\n    map_source_to_target\n        Optional mapping information passed through to ``display_cloud_mapping``.\n        Typically a torch.Tensor describing correspondences or flow-related weights.\n    color_mapping\n        Color used by the mapping overlay (RGBA hex supported).\n    label_source, label_target\n        Legend labels for source and target clouds.\n    color_source, color_target\n        Colors for the source and target scatter points (RGBA hex supported).\n    npoints\n        If provided, plot at most this many points from each cloud (head of the array).\n        Use ``None`` to plot all points.\n    figsize\n        Matplotlib figure size.\n    legend_loc\n        Legend location passed to ``plt.legend``.\n    tight_layout\n        Whether to call ``plt.tight_layout()`` before returning.\n\n    Returns\n    -------\n    matplotlib.figure.Figure\n        The created figure.\n\n    Raises\n    ------\n    ValueError\n        If indices are invalid or ``npoints`` is non-positive (when provided).\n    \"\"\"\n    # --- Basic parameter validation (display_* helpers do shape conversion/validation).\n    if npoints is not None:\n        if not isinstance(npoints, int) or npoints &lt;= 0:  # type: ignore[unnecessary-isinstance]\n            raise ValueError(\"npoints must be a positive integer or None.\")\n\n    if not isinstance(x_i, int) or not isinstance(y_i, int):  # type: ignore[unnecessary-isinstance]\n        raise ValueError(\"x_i and y_i must be integers.\")\n    if x_i == y_i:\n        # Usually unintended; helps catch accidental duplicate indices.\n        raise ValueError(\"x_i and y_i must be different columns.\")\n\n    # If a mapping is provided and torch is present, lightly validate type.\n    if map_source_to_target is not None:\n        if not isinstance(map_source_to_target, torch.Tensor):  # type: ignore[unnecessary-isinstance]\n            # Keep this soft to avoid importing NumPy here; downstream will error clearly if incompatible.\n            raise ValueError(\"map_source_to_target must be a torch.Tensor if provided.\")\n\n    # --- Build figure and single axis.\n    fig = plt.figure(figsize=figsize)\n    ax = fig.add_subplot(1, 1, 1)\n\n    # --- Draw source with mapping overlay (if provided).\n    display_cloud_mapping(\n        ax=ax,\n        x=source_pointcloud,\n        color=color_source,\n        x_i=x_i,\n        y_i=y_i,\n        v=map_source_to_target,\n        color_mapping=color_mapping,\n        label=label_source,\n        npoints=npoints,\n    )\n\n    # --- Draw target.\n    display_cloud(\n        ax=ax,\n        measure=target_pointcloud,\n        color=color_target,\n        x_i=x_i,\n        y_i=y_i,\n        label=label_target,\n        npoints=npoints,\n    )\n\n    plt.legend(loc=legend_loc)\n    if tight_layout:\n        plt.tight_layout()\n\n    return fig\n</code></pre>"},{"location":"reference/otcyto/plot/figure_umap/","title":"figure_umap","text":""},{"location":"reference/otcyto/plot/figure_umap/#otcyto.plot.figure_umap","title":"otcyto.plot.figure_umap","text":""}]}